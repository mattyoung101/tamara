#import "../../util/macros.typ": *

= Results
== Concept
To design the TaMaRa algorithm, I synthesise existing approaches from the literature review to form a novel
approach suitable for implementation in Yosys. Specifically, I synthesise the voter insertion algorithms of
Johnson @Johnson2010, the RTL annotation-driven approach of Kulis @Kulis2017, and parts of the verification
methodology of Benites @Benites2018 and Beltrame @Beltrame2015, to form the TaMaRa algorithm and verification
methodology. Based on the dichotomy identified in @section:litintro, TaMaRa will be classified as a
_netlist-level_ approach, as the algorithms are designed by treating the design as a circuit (rather than
HDL).

I propose a modification to the synthesis flow that inserts TaMaRa before technology mapping
(). This means that the circuit can be processed at a low level, with less concerns about
optimisation removing the redundant TMR logic. However, as shown in , some Yosys synthesis
scripts do perform additional optimisation _after_ technology mapping, which again risks the removal of the
TMR logic. Yet, we also cannot operate after technology mapping, since TaMaRa voter circuits are described
using relatively high level circuit primitives (AND gates, NOT gates, etc) instead of vendor-specific FPGA
primitives like LUTs. #TODO("whatever the solution for this is")

== Implementation
Over the course of this thesis, TaMaRa was successfully implemented as a Yosys plugin. This novel plugin
consists of around 2000 lines of C++20, and introduces one new command to Yosys: `tamara_tmr`.

=== Yosys background
Yosys supports dynamically loading plugins at runtime. These plugins are compiled against the Yosys codebase,
and are compiled into Unix shared objects (.so files). This allows users to define and register custom passes
and frontends within the main Yosys application, without having to trouble the upstream maintainers with the
maintenance of new code. This is precisely why the Yosys authors advised TaMaRa to be implemented as a Yosys
plugin, rather than as an upstream contribution @Engelhardt2024.

TaMaRa registers itself with Yosys by extending the `Yosys::Pass` interface, as the following snippet from
`tamara_tmr_pass.cpp` shows:

// TODO change verbatim size and make this a listing
```cpp
namespace tamara {

//! This is the main TaMaRa TMR command, which starts the TMR process.
struct TamaraTMRPass : public Pass {
    ...
};
```

TaMaRa operates at the netlist level, which in the context of Yosys means operating on RTL Intermediate
Language (RTLIL) circuits. In the Yosys hierarchy, RTLIL sits between the frontend and backend: it is
generated by a Verilog frontend, optimised, then transformed into an FPGA-specific netlist using a backend.
RTLIL is implemented as a set of C++ classes that describe the general structure of a netlist as wires
(`RTLIL::Wire`) and cells (`RTLIL::Cell`). Wires may potentially be multi-bit, which introduces a challenge as
TaMaRa voters are single-bit. Groups of wires and cells can be bundled into a module (`RTLIL::Module`).
Modules are arranged in a tree structure, where the root of the tree is known as the top module.

TaMaRa is currently designed to only operate on one module, that being the top module. This is typical of
space applications. For example, consider a Verilog top module called `cpu_top` that contains a 32-bit RISC-V
CPU, along with its register file, ALU, memory and instruction decoder. To ensure full rad-hard reliability in
space, the whole `cpu_top` module needs to be triplicated. However, in the future, it would be a nice feature
to be able to have finer grained control over the parts of the design are triplicated. This does unfortunately
introduce some significant problems that will be elaborated on later.

=== TaMaRa TMR algorithm implementation
Broadly speaking, TaMaRa applies the following algorithm:

1. Analyse the RTLIL netlist to generate `tamara::RTLILWireConnections` mapping; which is a mapping between an
    RTLIL Cell or Wire and the other Cells or Wires it may be connected to.
2. For each output port in the top module:
    1. Perform a backwards breadth-first search through the RTLIL netlist to form a logic cone
        (`tamara::LogicCone`)
    2. Replicate all combinatorial RTLIL primitives inside the logic cone
    3. Insert the necessary voter(s) for each bit
    4. Wire up the newly formed netlist, including connected the voters and performing any necessary fixes
        (see `tamara::FixWalker`, `tamara::FixWalkerManager` and `tamara::MultiDriverFixer`)
3. With the initial search complete, compute any follow on/successor logic cones from the initial terminals
4. Repeat step 2 but for each successor logic cone
5. Continue until no more successors remain

#TODO("diagram")

#TODO("need to cover what a logic cone actually is")

#TODO("talk about FixWalkers")

#TODO("talk about the wiring process in detail")

== Verification
=== Manual verification
=== Formal verification
=== RTL fuzzing techniques
