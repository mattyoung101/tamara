#import "../../util/macros.typ": *

= Methodology
== Concept
To design the TaMaRa algorithm, I synthesise existing approaches from the literature review to form a novel
approach suitable for implementation in Yosys. Specifically, I synthesise the voter insertion algorithms of
Johnson @Johnson2010, the RTL annotation-driven approach of Kulis @Kulis2017, and parts of the verification
methodology of Benites @Benites2018 and Beltrame @Beltrame2015, to form the TaMaRa algorithm and verification
methodology. Based on the dichotomy identified in @section:litintro, TaMaRa will be classified as a
_netlist-level_ approach, as the algorithms are designed by treating the design as a circuit (rather than
HDL).

I propose a modification to the synthesis flow that inserts TaMaRa before technology mapping (). This means
that the circuit can be processed at a low level, with less concerns about optimisation removing the redundant
TMR logic. However, as shown in , some Yosys synthesis scripts do perform additional optimisation _after_
technology mapping, which again risks the removal of the TMR logic. Yet, we also cannot operate after
technology mapping, since TaMaRa voter circuits are described using relatively high level circuit primitives
(AND gates, NOT gates, etc) instead of vendor-specific FPGA primitives like LUTs.
#TODO("whatever the solution for this is")

Whilst TaMaRa aims to be compatible with all existing designs with minimal changes, some preconditions are
necessary for the algorithm to process the circuit correctly.

Since the algorithm wants to work with all possible circuits, it cannot predict what the end user wants to do
with the voter error signal (if anything). As discussed in the literature review, the typical use case for the
error signal is to perform configuration scrubbing when upsets are detected. This, however, is a highly
vendor-specific process for FPGAs, and is not at all possible on ASICs. As TaMaRa targets FPGAs from any
vendor, and ASICs as well, a more general approach is necessary. To solve this problem, TaMaRa does not aim to
provide configuration scrubbing directly, instead leaving this for the end user. Instead, the end user can
attach an HDL annotation to indicate an output port on a module that TaMaRa should wire a global voter error
signal to. In SystemVerilog, this uses the `(* tamara_error_sink *)` annotation, as shown in @lst:errorsink:

#figure(
    ```systemverilog
    module mod(
        input logic a,
        (* tamara_error_sink *)
        output logic b
    );
    ```,
    caption: [ SystemVerilog snippet demonstrating the use of the `(* tamara_error_sink *)` annotation ]
) <lst:errorsink>

End users are then free to implement configuration scrubbing using the tool and methodology appropriate to
their platform.

== Implementation
Over the course of this thesis, TaMaRa was successfully written from the ground up as a Yosys plugin. This
plugin consists of around 2000 lines of C++20, and introduces one new command to Yosys: `tamara_tmr`.

=== Yosys background
Yosys supports dynamically loading plugins at runtime. These plugins are compiled against the Yosys codebase,
and are compiled into Unix shared objects (.so files). This allows users to define and register custom passes
and frontends within the main Yosys application, without having to trouble the upstream maintainers with the
maintenance of new code. This is precisely why the Yosys authors advised TaMaRa to be implemented as a Yosys
plugin, rather than as an upstream contribution @Engelhardt2024. This plugin system is a unique and powerful
part of Yosys, and one of the main advantages of the tool being open-source. End users are free to design and
implement their own plugins, under their own choice of licence, to extend Yosys in any way they see fit.
Comparatively, proprietary tools are limited to rather simple Tcl scripting, as was used by Benites
@Benites2018.

TaMaRa registers itself with Yosys by extending the `Yosys::Pass` interface, using a main
`struct TamaraTMRPass` in `tamara_tmr_pass.cpp`.

TaMaRa operates at the netlist level, which in the context of Yosys means operating on RTL Intermediate
Language (RTLIL) circuits. In the Yosys hierarchy, RTLIL sits between the frontend and backend: it is
generated by a Verilog frontend, optimised, then transformed into an FPGA-specific netlist using a backend.
RTLIL is implemented as a set of C++ classes that describe the general structure of a netlist as wires
(`RTLIL::Wire`) and cells (`RTLIL::Cell`). Wires may potentially be multi-bit, which introduces a challenge as
TaMaRa voters are single-bit. Groups of wires and cells can be bundled into a module (`RTLIL::Module`).
Modules are arranged in a tree structure, where the root of the tree is known as the top module. RTLIL is one
of the most important and powerful parts of Yosys, because it allows plugins like TaMaRa to operate on a
common intermediate representation of a circuit netlist, irrespective of the user's choice of input RTL
language and/or output type. This means that TaMaRa can operate exactly the same for a user using VHDL for a
Lattice iCE40 FPGA, and a user using Verilog for a Skywater 130 nm ASIC. RTLIL's importance is further
elaborated on by Wolf @Wolf2013 and Shah et al. @Shah2019.

TaMaRa is currently designed to only operate on one module, that being the top module. This is typical of
space applications. For example, consider a Verilog top module called `cpu_top` that contains a 32-bit RISC-V
CPU, along with its register file, ALU, memory and instruction decoder. To ensure full rad-hard reliability in
space, the whole `cpu_top` module needs to be triplicated. However, in the future, it would be a nice feature
to be able to have finer grained control over the parts of the design are triplicated. This does unfortunately
introduce some significant problems that will be elaborated on later.

=== TaMaRa TMR algorithm implementation
#figure(
    image("../../diagrams/classdiagram.svg"),
    caption: [ Class diagram of the TaMaRa codebase ]
) <fig:classdiagram>

TaMaRa consists of multiple C++ classes (@fig:classdiagram). Broadly speaking, these classes combine together
to form the following algorithm. This is also shown in @fig:algodiagram.

1. Analyse the RTLIL netlist to generate `tamara::RTLILWireConnections` mapping; which is a mapping between an
    RTLIL Cell or Wire and the other Cells or Wires it may be connected to.
2. For each output port in the top module:
    1. Perform a backwards breadth-first search through the RTLIL netlist to form a logic cone
        (`tamara::LogicCone`)
    2. Replicate all combinatorial RTLIL primitives inside the logic cone
    3. Insert the necessary voter(s) for each bit
    4. Wire up the newly formed netlist, including connected the voters and performing any necessary fixes
        (see `tamara::FixWalker`, `tamara::FixWalkerManager` and `tamara::MultiDriverFixer`)
3. With the initial search complete, compute any follow on/successor logic cones from the initial terminals
4. Repeat step 2 but for each successor logic cone
5. Continue until no more successors remain

#figure(
    image("../../diagrams/algorithm.svg", width: 85%),
    caption: [ Logic flow of the TaMaRa TMR algorithm ]
) <fig:algodiagram>

#TODO("need to cover what a logic cone actually is - or do we cover that enough earlier?")

One of the most important aspects of the TaMaRa algorithm is its ability to handle multi-bit wiring. In Yosys'
RTLIL representation, an `RTLIL::Wire` instance may also be a bus, not just a single bit wire. This
complicates matters, because the `tamara::VoterBuilder` class can only handle single bit voters. TaMaRa
handles multi-bit wires through a mix of user commands and internal TaMaRa code. The user is instructed to run
the Yosys commands `splitcells; splitnets;` beforehand as part of their synthesis script, which splits up
internal multi-bit wires and cells into multiple single-bit wires and cells. This, however, still means that
the output ports are multi-bit. To handle this, TaMaRa's `VoterBuilder` class has the ability to take an
$N$-bit input signal, and split it into $N$ individual voters. Then, once all the $N$ voters have been
generated, the `VoterBuilder` feeds the correct voter `out` bit to the output port. It is also capable of
producing a correct error signal by OR'ing together all the voter error signals using a Yosys `$reduce_or`
cell. Furthermore, the `VoterBuilder` is capable of OR'ing together multiple of these `$reduce_or` cells to
handle multiple voters across multiple logic cones. This works by building an "OR chain", which is a chain of
`$reduce_or` cells that are themselves OR'd together.

#TODO("Yosys 'show' result of VoterBuilder OR chain and $reduce_or")

#TODO("talk about the wiring process in (more) detail")

Once wiring is completed, however, there is still more work the algorithm needs to do. There are many wiring
edge cases that are not handled correctly by the initial pass, and so the `tamara::FixWalker` and
`tamara::FixWalkerManager` was designed as a modular method to "fix up" specific wiring edge cases. The
`FixWalkerManager` analyses the RTLIL netlist, and runs a number of callbacks for each provided `FixWalker` to
consider individual cells, wires and modules. One important `FixWalker` instance is the `MultiDriverFixer`.
When the algorithm replicates wires (`ElementWireNode` instances, specifically), it causes some wire instances
to have three separate, conflicting drivers, which is not legal in an RTLIL netlist.

Relatively speaking, the above description is only a minimal summary of the wiring logic of the TaMaRa
algorithm. In reality, RTLIL wiring is highly complex and the logic to handle multi-bit wiring in all possible
cases was hundreds of lines of code. One specific example that deserves attention is when an output signal is
itself multi-bit, which requires an enormous procedure to detect available `RTLIL::SigBit`s and route the
wires accordingly, plus the relevant error handling code. This was a complex task that took a significant
amount of overall development time of the algorithm.

In general, the TaMaRa code is designed to be robust to any and all user inputs, and easy to debug when the
algorithm does not work as expected. This is achieved by a combination of detailed, friendly error reporting
and copious `assert` statements available in debug builds. For example, if a user specifies an error port
marked `(* tamara_error_sink *)` that is multi-bit, which is not supported, TaMaRa will print an error
explaining this in detail. The algorithm also performs self-checking using `assert` statements throughout the
process to catch internal errors that may occur. For example, @lst:tamara_error demonstrates how logic
cones are checked to conform with their specification (they may only start with an `IONode` or an `FFNode`).

#figure(
    ```cpp
    void LogicCone::verifyInputNodes() const {
        for (const auto &node : inputNodes) {
            if (dynamic_pointer_cast<IONode>(node) == nullptr && dynamic_pointer_cast<FFNode>(node) == nullptr) {
                log_error("TaMaRa internal error: Logic cone input node should be either IONode or FFNode, but "
                          "instead it was %s %s!\n",
                    node->identify().c_str(), log_id(getNodeName(node)));
            }
        }
    }
    ```,
    caption: [ Example of TaMaRa internal error handling code ]
) <lst:tamara_error>

The friendly error reporting is designed as a "first line of defence" for the most common user errors, and the
addition of asserts plays an important role in debugging end user crashes. Ideally, TaMaRa will rather crash
then generate an impossible design. All of this combines together to hopefully make a tool that users can be
confident deploying in rad-hardened, safety critical scenarios.

=== Software engineering considerations
TaMaRa is a highly complex project that, during the course of this one year thesis, developed into a
substantial and complicated codebase. Far from just being a research project, this thesis is also a software
engineering project as well. This means that, in addition to the usual research considerations, there are also
a number of software engineering considerations that are noted here.

The TaMaRa algorithm itself is complex, and it builds on top of the very complex Yosys codebase. In addition,
the very process of EDA synthesis is highly non-trivial; akin to writing a compiler. This means that an
extensive verification methodology is required not just as a once-off, but throughout development. While the
verification methodology is covered throughout @section:verification, there are some important software
engineering considerations about _how_ this was implemented.

#TODO("")
- Poor design decisions that we had initially (RTLILWireConnections)
- Not using SigSpec
- Regression test suite

== Verification <section:verification>
Due to its use in safety critical sectors like aerospace and defence, comprehensive verification and testing
of the TaMaRa flow is extremely important in this thesis. We want to verify to a very high level of accuracy
that TaMaRa both works by preventing SEUs to an acceptable standard, and also does not change the underlying
behaviour of the circuits it processes.

=== Manual verification
The design and use of RTL testbenches has, and continues to be important when designing FPGA and ASIC
projects. Likewise, RTL testbenches are very important when designing EDA tools. Compared to FPGA/ASIC design,
when working on EDA tools, having a representative sample of a large number of projects is the most important
aspect. For TaMaRa, I sourced a number of representative small open-source Verilog projects with acceptable
licences for inclusion in the `test` directory. These designs include:
- Various cyclic redundancy check (CRC) calculators of varying bit-depths
    - Tests TaMaRa's handling of combinatorial circuits
- Small RISC-V CPUs: picorv32, femtorv32, minimax, Browndeer Technologies' rv8
    - CPUs are highly representative of large Verilog projects, and include complex combinatorial and
        sequential circuits

In addition, I also wrote a number of much smaller testbenches to target specific bugs or specific features in
TaMaRa. These were very important in the initial development and verification of the algorithm, as their tiny
size allowed for visual debugging using Yosys' `show` command. For example, one of the most important tests
was `not_dff_tmr.sv`, a simple NOT-gate into a D-flip-flop, whose SystemVerilog code is shown in
@lst:notdfftmr.

#figure(
    ```systemverilog
    (* tamara_triplicate *)
    module not_dff_tmr(
        input logic a,
        input logic clk,
        output logic o,
        (* tamara_error_sink *)
        output logic err
    );

    logic ff;

    always_ff @(posedge clk) begin
        ff <= a;
    end

    assign o = !ff;

    `ifndef TAMARA
    assign err = 0;
    `endif

    endmodule
    ```,
    caption: [ SystemVerilog source code for `not_dff_tmr`, a key initial testbench ]
) <lst:notdfftmr>

=== Formal verification
Formal verification is increasingly being pursued in the development of FPGAs and ASICs as part of a
comprehensive design verification methodology. The foundations for the formal verification of digital circuits
extend back to traditional Boolean algebra and set theory in discrete mathematics. Building on these
foundations, digital circuit verification can be represented as a Boolean satisfiability ("SAT") problem.
#TODO("Describe SAT in more detail")
Via the Cook-Levin theorem, as proved by Karp @Karp1972, we know that SAT is an
NP-complete problem (i.e. there is likely no polynomial time solution). Despite this, there exist a number of
fast-enough SAT solvers @Sorensson2005 @Audemard2018, that make the verification of Boolean circuits
using SAT a tractable problem.

However, on large and complex designs, using SAT solvers directly on multi-bit buses can be slow. Instead,
Satisfiability Modulo Theories (SMT) solvers can be used instead. SMT is a generalisation of SAT that
introduces richer types such as bit vectors, integers, and reals @Barrett2018. Solving satisfiability modulo
theories is still at least NP-complete, sometimes undecidable. Most SMT solvers either depend on or "call out"
to an underlying SAT solver. One such SMT solver that uses this approach is Bitwuzla @Niemetz2023. Others,
however, such as Z3 @Moura2008 include their own SAT logic and other methods for computing solutions. The
speed of SMT solvers is very important when performing formal verification of digital circuits, and there is a
yearly SMT solving competition to encourage the development and analysis of high-performance SMT solvers
@Weber2019.

For TaMaRa specifically, formal verification is abstracted through the use of Yosys' `eqy`, `mcy` and `sby`
(SymbiYosys) tools. `eqy` is used for formal equivalence checking between two circuits, and is responsible for
partitioning the input circuit to a form suitable for equivalence checking. This is then sent on to `sby`,
which in turn transforms the circuit into a suitable SMT proof for an SMT solver. TaMaRa was going to use the
Bitwuzla @Niemetz2023 solver, but due to upstream issues with both Yosys and Bitwuzla, settled for using the
industry standard Yices @Dutertre2014, which is quite fast. `mcy`, Yosys' mutation coverage tool, was
originally written to verify the correctness of self-checking testbenches and verify the coverage of a
project's testbenches. Essentially, it injects faults into a design and verifies that the self-checking
testbench correctly flags these mutated designs as invalid.
#TODO("MCY and SBY")

The purpose of applying equivalence checking to the TaMaRa verification flow is to formally prove (for
specific circuits, at least) that the tool holds up one of its key properties: that it does not change the
underlying behaviour of the circuit during processing. We could also check this using testbenches, or for
simple combinatorial circuits by comparing the truth table manually, but SMT-based formal equivalence checking
supports all circuit types and is much more reliable. If the formal equivalence check passes, we can be
absolutely certain that the behaviour of the circuit has not changed, for all possible inputs; and for
sequential circuits, for all possible inputs _and_ all possible states.

Mutation coverage is slightly more complex, but essentially allows us to prove for a particular circuit that
TaMaRa actually corrects a number of different variations of simulated SEUs. Using a technique developed by
Engelhardt @mcyfault, we use `mcy`'s fault injection capabilities to 

=== RTL fuzzing techniques
In the software world, "fuzzing" refers to a process of randomly generating inputs designed to induce
problematic behaviour in programs. Typically, fuzzing is started by referencing an initial corpus, and the
program under test is then instrumented to add control flow tracking code. The goal of the fuzzer is to
generate inputs such that the program reaches 100% instrumented branch coverage once the fuzzing process is
completed.

While fuzzing is typically started from an initial corpus, there has also been interest in fuzzing languages
directly without any initial examples, using information from the language's grammar. One example is Holler's
LangFuzz @Holler2012, which uses a tree formed by the JavaScript grammar to generate random, but valid,
JavaScript code. Mozilla developers have used LangFuzz successfully to find numerous bugs in their
SpiderMonkey JavaScript engine. Generating code from the grammar directly also has the advantage of making the
fuzzing process significantly more efficient, as the fuzzer tool has the _a priori_ knowledge necessary to
"understand" the language. Compared to using a general purpose random fuzzer that typically generates and
mutates test cases on a byte-by-byte basis @Fioraldi2020, grammar fuzzers should be able to get significantly
higher coverage of a target program much more efficiently.

Although these techniques are typically used for software projects, they can also be useful for hardware,
particularly for EDA tools. Herklotz @Herklotz2020 describes "Verismith", a tool capable of generating random
and correct Verilog RTL. This is useful for TaMaRa verification, because it allows us to investigate _en
masse_ whether the tool changes the behaviour of the underlying circuit. Hence, part of the TaMaRa
verification flow will involve using Verismith to generate small random Verilog designs, and running TaMaRa
end-to-end on these designs. Initially, we will be looking for crashes, assert failures and memory errors
using AddressSanitizer, but later we will also use Yosys' eqy tool to prove that the designs stay the same
before and after TaMaRa runs. Using the GNU Parallel tool, this work can be trivially distributed across
multiple cores. Running TaMaRa with the Verismith fuzzer on 1000 designs takes around 5 minutes on an AMD
Ryzen 9 5950X workstation.
