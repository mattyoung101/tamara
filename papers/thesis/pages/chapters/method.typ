#import "../../util/macros.typ": *

= Methodology
== Concept
To design the TaMaRa algorithm, I synthesise existing approaches from the literature review to form a novel
approach suitable for implementation in Yosys. Specifically, I synthesise the voter insertion algorithms of
Johnson @Johnson2010, the RTL annotation-driven approach of Kulis @Kulis2017, and parts of the verification
methodology of Benites @Benites2018 and Beltrame @Beltrame2015, to form the TaMaRa algorithm and verification
methodology. Based on the dichotomy identified in @section:litintro, TaMaRa will be classified as a
_netlist-level_ approach, as the algorithms are designed by treating the design as a circuit (rather than
HDL).

I propose a modification to the synthesis flow that inserts TaMaRa before technology mapping
(). This means that the circuit can be processed at a low level, with less concerns about
optimisation removing the redundant TMR logic. However, as shown in , some Yosys synthesis
scripts do perform additional optimisation _after_ technology mapping, which again risks the removal of the
TMR logic. Yet, we also cannot operate after technology mapping, since TaMaRa voter circuits are described
using relatively high level circuit primitives (AND gates, NOT gates, etc) instead of vendor-specific FPGA
primitives like LUTs. #TODO("whatever the solution for this is")

Whilst TaMaRa aims to be compatible with all existing designs with minimal changes, some preconditions are
necessary for the algorithm to process the circuit correctly.

Since the algorithm wants to work with all possible circuits, it cannot predict what the end user wants to do
with the voter error signal (if anything). As discussed in the literature review, the typical use case for the
error signal is to perform configuration scrubbing when upsets are detected. This, however, is a highly
vendor-specific process for FPGAs, and is not at all possible on ASICs. As TaMaRa targets FPGAs from any
vendor, and ASICs as well, a more general approach is necessary. To solve this problem, TaMaRa does not aim to
provide configuration scrubbing directly, instead leaving this for the end user. Instead, the end user can
attach an HDL annotation to indicate an output port on a module that TaMaRa should wire a global voter error
signal to. In SystemVerilog, this uses the `(* tamara_error_sink *)` annotation, as shown in @lst:errorsink:

#figure(
    ```systemverilog
    module mod(
        input logic a,
        (* tamara_error_sink *)
        output logic b
    );
    ```,
    caption: [ SystemVerilog snippet demonstrating the use of the `(* tamara_error_sink *)` annotation ]
) <lst:errorsink>

End users are then free to implement configuration scrubbing using the tool and methodology appropriate to
their platform.

== Implementation
Over the course of this thesis, TaMaRa was successfully written from the ground up as a Yosys plugin. This
plugin consists of around 2000 lines of C++20, and introduces one new command to Yosys: `tamara_tmr`.

=== Yosys background
Yosys supports dynamically loading plugins at runtime. These plugins are compiled against the Yosys codebase,
and are compiled into Unix shared objects (.so files). This allows users to define and register custom passes
and frontends within the main Yosys application, without having to trouble the upstream maintainers with the
maintenance of new code. This is precisely why the Yosys authors advised TaMaRa to be implemented as a Yosys
plugin, rather than as an upstream contribution @Engelhardt2024. This plugin system is a unique and powerful
part of Yosys, and one of the main advantages of the tool being open-source. End users are free to design and
implement their own plugins, under their own choice of licence, to extend Yosys in any way they see fit.
Comparatively, proprietary tools are limited to rather simple Tcl scripting, as was used by Benites
@Benites2018.

TaMaRa registers itself with Yosys by extending the `Yosys::Pass` interface, using a main
`struct TamaraTMRPass` in `tamara_tmr_pass.cpp`.

TaMaRa operates at the netlist level, which in the context of Yosys means operating on RTL Intermediate
Language (RTLIL) circuits. In the Yosys hierarchy, RTLIL sits between the frontend and backend: it is
generated by a Verilog frontend, optimised, then transformed into an FPGA-specific netlist using a backend.
RTLIL is implemented as a set of C++ classes that describe the general structure of a netlist as wires
(`RTLIL::Wire`) and cells (`RTLIL::Cell`). Wires may potentially be multi-bit, which introduces a challenge as
TaMaRa voters are single-bit. Groups of wires and cells can be bundled into a module (`RTLIL::Module`).
Modules are arranged in a tree structure, where the root of the tree is known as the top module. RTLIL is one
of the most important and powerful parts of Yosys, because it allows plugins like TaMaRa to operate on a
common intermediate representation of a circuit netlist, irrespective of the user's choice of input RTL
language and/or output type. This means that TaMaRa can operate exactly the same for a user using VHDL for a
Lattice iCE40 FPGA, and a user using Verilog for a Skywater 130 nm ASIC. RTLIL's importance is further
elaborated on by Wolf @Wolf2013 and Shah et al. @Shah2019.

TaMaRa is currently designed to only operate on one module, that being the top module. This is typical of
space applications. For example, consider a Verilog top module called `cpu_top` that contains a 32-bit RISC-V
CPU, along with its register file, ALU, memory and instruction decoder. To ensure full rad-hard reliability in
space, the whole `cpu_top` module needs to be triplicated. However, in the future, it would be a nice feature
to be able to have finer grained control over the parts of the design are triplicated. This does unfortunately
introduce some significant problems that will be elaborated on later.

=== TaMaRa TMR algorithm implementation
#figure(
    image("../../diagrams/classdiagram.svg"),
    caption: [ Class diagram of the TaMaRa code ]
) <fig:classdiagram>

TaMaRa consists of multiple C++ classes (@fig:classdiagram). Broadly speaking, these classes combine together
to form the following algorithm. This is also shown in @fig:algodiagram.

1. Analyse the RTLIL netlist to generate `tamara::RTLILWireConnections` mapping; which is a mapping between an
    RTLIL Cell or Wire and the other Cells or Wires it may be connected to.
2. For each output port in the top module:
    1. Perform a backwards breadth-first search through the RTLIL netlist to form a logic cone
        (`tamara::LogicCone`)
    2. Replicate all combinatorial RTLIL primitives inside the logic cone
    3. Insert the necessary voter(s) for each bit
    4. Wire up the newly formed netlist, including connected the voters and performing any necessary fixes
        (see `tamara::FixWalker`, `tamara::FixWalkerManager` and `tamara::MultiDriverFixer`)
3. With the initial search complete, compute any follow on/successor logic cones from the initial terminals
4. Repeat step 2 but for each successor logic cone
5. Continue until no more successors remain

#figure(
    image("../../diagrams/algorithm.svg", width: 85%),
    caption: [ General overview of the TaMaRa TMR diagram ]
) <fig:algodiagram>

#TODO("need to cover what a logic cone actually is - or do we cover that enough earlier?")

One of the most important aspects of the TaMaRa algorithm is its ability to handle multi-bit wiring. In Yosys'
RTLIL representation, an `RTLIL::Wire` instance may also be a bus, not just a single bit wire. This
complicates matters, because the `tamara::VoterBuilder` class can only handle single bit voters. TaMaRa
handles multi-bit wires through a mix of user commands and internal TaMaRa code. The user is instructed to run
the Yosys commands `splitcells; splitnets;` beforehand as part of their synthesis script, which splits up
internal multi-bit wires and cells into multiple single-bit wires and cells. This, however, still means that
the output ports are multi-bit. To handle this, TaMaRa's `VoterBuilder` class has the ability to take an
$N$-bit input signal, and split it into $N$ individual voters. Then, once all the $N$ voters have been
generated, the `VoterBuilder` feeds the correct voter `out` bit to the output port. It is also capable of
producing a correct error signal by OR'ing together all the voter error signals using a Yosys `$reduce_or`
cell. Furthermore, the `VoterBuilder` is capable of OR'ing together multiple of these `$reduce_or` cells to
handle multiple voters across multiple logic cones. This works by building an "OR chain", which is a chain of
`$reduce_or` cells that are themselves OR'd together.

#TODO("Yosys 'show' result of VoterBuilder OR chain and $reduce_or")

#TODO("talk about the wiring process in (more) detail")

Once wiring is completed, however, there is still more work the algorithm needs to do. There are many wiring
edge cases that are not handled correctly by the initial pass, and so the `tamara::FixWalker` and
`tamara::FixWalkerManager` was designed as a modular method to "fix up" specific wiring edge cases. The
`FixWalkerManager` analyses the RTLIL netlist, and runs a number of callbacks for each provided `FixWalker` to
consider individual cells, wires and modules. One important `FixWalker` instance is the `MultiDriverFixer`.
When the algorithm replicates wires (`ElementWireNode` instances, specifically), it causes some wire instances
to have three separate, conflicting drivers, which is not legal in an RTLIL netlist.

In general, the TaMaRa code is designed to be robust to any and all user inputs, and easy to debug when the
algorithm does not work as expected. This is achieved by a combination of detailed, friendly error reporting
and copious `assert` statements available in debug builds. For example, if a user specifies an error port
marked `(* tamara_error_sink *)` that is multi-bit, which is not supported, TaMaRa will print an error
explaining this in detail. The algorithm also performs self-checking using `assert` statements throughout the
process to catch internal errors that may occur. For example, @lst:tamara_error demonstrates how logic
cones are checked to conform with their specification (they may only start with an `IONode` or an `FFNode`).

#figure(
    ```cpp
    void LogicCone::verifyInputNodes() const {
        for (const auto &node : inputNodes) {
            if (dynamic_pointer_cast<IONode>(node) == nullptr && dynamic_pointer_cast<FFNode>(node) == nullptr) {
                log_error("TaMaRa internal error: Logic cone input node should be either IONode or FFNode, but "
                          "instead it was %s %s!\n",
                    node->identify().c_str(), log_id(getNodeName(node)));
            }
        }
    }
    ```,
    caption: [ Example of TaMaRa internal error handling code ]
) <lst:tamara_error>

The friendly error reporting is designed as a "first line of defence" for the most common user errors, and the
addition of asserts plays an important role in debugging end user crashes. Ideally, TaMaRa will rather crash
then generate an impossible design. All of this combines together to hopefully make a tool that users can be
confident deploying in rad-hardened, safety critical scenarios.

== Verification
=== Manual verification
=== Formal verification
=== RTL fuzzing techniques
