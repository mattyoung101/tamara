// TaMaRa: An automated triple modular redundancy EDA flow for Yosys.
//
// Copyright (c) 2024 Matt Young.
//
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
#include "kernel/celltypes.h"
#include "kernel/log.h"
#include "kernel/register.h"
#include "kernel/rtlil.h"
#include "kernel/yosys_common.h"
#include "tamara/logic_graph.hpp"
#include "tamara/termcolour.hpp"
#include "tamara/util.hpp"
#include "tamara/voter_builder.hpp"
#include <cmath>
#include <unordered_set>
#include <vector>

USING_YOSYS_NAMESPACE;

namespace tamara {

//! This is the main TaMaRa TMR command, which starts the TMR process.
struct TamaraTMRPass : public Pass {

    TamaraTMRPass()
        : Pass("tamara_tmr", "Performs TaMaRa TMR voter insertion and cell replication") {
    }

    void help() override {
        //   |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
        log("\n");
        log("    tamara_tmr\n");
        log("\n");

        log("TaMaRa is an automated triple modular redundancy flow for Yosys.\n");
        log("The 'tamara_tmr' command processes exactly one selected module in the\n");
        log("design, which should be the top module. It will apply TMR and insert\n");
        log("majority voters.\n\n");

        log("The 'tamara_tmr' command should be run after synthesis but before\n");
        log("techmapping.\n");
    }

    void execute(std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Running TaMaRa automated Triple Modular Redundancy flow\n\n");

        // FIXME: find module marked (* tamara_triplicate *)

        // we can only operate on one module
        if (design->top_module() == nullptr) {
            log_error("No top module selected\n");
        }

        auto *const module = design->top_module();
        log("Applying TMR to top module: %s\n", log_id(module->name));
        log_push();

        VoterBuilder builder(module);

        // locate the error sink (place where we route the voter 'err' signals too)
        log_header(design, "Locating error sink\n");
        locateErrorSink(design->top_module());

        // analyse wire connections, this is used later by the logic cone code for neighbour calculations
        // I thought that we might be able to get this through RTLIL directly, but I think we have to compute
        // it ourselves.
        // the main trouble is we have to compute it in reverse: that is, we want to know which _wires_ have
        // which _cells_ associated with them, but RTLIL will only tell us which _cells_ have which _wires_
        // associated with them.
        log_header(design, "Analysing wire connections\n");
        auto neighbours = analyseConnections(module, design);

        // figure out where our output ports are, these will be the start of the BFS
        log_header(design, "Computing initial logic graph\n");
        auto outputs = getOutputPorts(module);
        log("Module has %zu output ports, %zu selected cells\n\n", outputs.size(),
            module->selected_cells().size());

        // this is a list of successors generated by the backwards BFS
        auto successors = std::queue<LogicCone>();

        for (const auto &output : outputs) {
            // don't consider ports marked (* tamara_error_sink *)
            if (output->has_attribute(ERROR_SINK_ANNOTATION)) {
                log("Skipping output '%s', marked as TaMaRa error sink\n\n", log_id(output->name));
                continue;
            }

            log("Searching from output port %s\n", log_id(output->name));
            auto cone = LogicCone(output);

            // start at the output port, do a BFS backwards to build up our logic cones
            cone.search(module, neighbours);
            log("\n");

            // cone is built, replicate items
            cone.replicate(module);
            log("\n");

            // wire up the netlist, and insert a voter
            cone.wire(module, errorSink, neighbours, builder);
            log("\n");

            // generate successors
            auto coneSuccessors = cone.buildSuccessors(neighbours);
            for (const auto &successor : coneSuccessors) {
                successors.push(successor);
            }
            log("\n");
        }

        log_header(design, "Computing successor logic graph (%zu successors)\n", successors.size());
        while (!successors.empty()) {
            auto cone = successors.front();
            successors.pop();

            // start at the output port, do a BFS backwards to build up our logic cones
            cone.search(module, neighbours);
            log("\n");

            // cone is built, replicate items
            cone.replicate(module);
            log("\n");

            // wire up the netlist
            cone.wire(module, errorSink, neighbours, builder);
            log("\n");

            // generate successors
            auto coneSuccessors = cone.buildSuccessors(neighbours);
            for (const auto &successor : coneSuccessors) {
                successors.push(successor);
            }
            log("\n");
        }

        // collect all error signals from all voters in the design, ORs them together, and connects them to
        // the (* tamara_error_sink *) node (if it exists).
        log_header(design, "Sinking error nodes into (* tamara_error_sink *)\n");
        if (errorSink.has_value()) {
            log("Sinking %zu voters into (* tamara_error_sink *) %s\n", builder.getSize(),
                log_id(errorSink.value()->name));
            builder.finalise(errorSink.value());
        } else {
            log_warning("Cannot sink voters into error sink because no error sink was found!\n");
        }

        log("\n===============================\n");
        log("%sTaMaRa TMR pass completed!%s\n", termcolour::colour(termcolour::Colour::Green).c_str(),
            termcolour::reset().c_str());
        log("===============================\n");
        log_pop();
    }

private:
    std::optional<RTLIL::Wire *> errorSink;

    //! Determines if the cells annotations are suitable to triplicate
    static constexpr bool shouldConsiderForTMR(const RTLIL::AttrObject *obj) {
        return !obj->has_attribute(IGNORE_ANNOTATION);
    }

    //! Inserts a value into the hashmap, or adds it then inserts if not present
    static constexpr void addConnection(
        RTLILWireConnections &connections, RTLILAnyPtr key, const RTLILAnyPtr &value) {
        if (!connections.contains(key)) {
            connections[key] = std::unordered_set<RTLILAnyPtr>();
        }
        connections[key].insert(value);
    }

    //! Returns output wires for a module
    static std::vector<RTLIL::Wire *> getOutputPorts(RTLIL::Module *module) {
        std::vector<RTLIL::Wire *> out {};
        for (const auto &wire : module->wires()) {
            if (wire->port_output) {
                out.push_back(wire);
            }
        }
        return out;
    }

    //! Analyses connections betweens wires and the other wires or cells they're connected to
    static RTLILWireConnections analyseConnections(const RTLIL::Module *module, RTLIL::Design *design) {
        RTLILWireConnections connections {};

        // usage of CellTypes is based off Yosys' show command
        CellTypes cellTypes(design);

        for (const auto &cell : module->selected_cells()) {
            // cells that are ignored by TaMaRa should never be neighbours
            if (!shouldConsiderForTMR(cell)) {
                log("Skipping cell %s, not marked tamara_triplicate\n", log_id(cell->name));
                continue;
            }

            log("Checking connections for cell: %s (%zu connections)\n", log_id(cell->name),
                cell->connections().size());

            // find wires that this is connected to
            for (const auto &connection : cell->connections()) {
                const auto &[name, signal] = connection;

                Wire *wire = sigSpecToWire(signal);
                if (wire == nullptr) {
                    log_warning("Trouble accessing wire from connection '%s'\n", log_id(name));
                    continue;
                }

                // this is an output from the cell, so connect wire -> cell (remember we work backwards)
                if (cellTypes.cell_output(cell->type, name)) {
                    addConnection(connections, wire, cell);
                    log("[neighbour] wire %s --> cell %s\n", log_id(wire->name), log_id(cell->name));
                }

                // this is an input to the cell, so connect cell -> wire (remember we work backwards)
                if (cellTypes.cell_input(cell->type, name)) {
                    addConnection(connections, cell, wire);
                    log("[neighbour] cell %s --> wire %s\n", log_id(cell->name), log_id(wire->name));
                }
            }
            log("\n");
        }

        // also add global connections
        // TODO check if this is actually required or not
        log("Checking global module connections\n");
        for (const auto &connection : module->connections()) {
            const auto &[lhs, rhs] = connection;

            // FIXME it seems like this never triggers
            if (rhs.is_wire() && lhs.is_wire()) {
                auto *const lhsWire = lhs.as_wire();
                auto *const rhsWire = rhs.as_wire();
                if (shouldConsiderForTMR(lhsWire) && shouldConsiderForTMR(rhsWire)) {
                    log("[neighbour] %s --> %s\n", log_id(lhsWire->name), log_id(rhsWire->name));

                    // apparently we don't actually need to reverse this, we're ok to just map lhs -> rhs
                    // despite doing backwards BFS
                    addConnection(connections, lhsWire, rhsWire);
                }
            } else {
                // TODO get name, if possible?
                log("Either RHS or LHS SigSpec is not a wire, skipping\n");
            }
        }

        log("\nDone, located %zu neighbours from %zu cells\n", connections.size(),
            module->selected_cells().size());
        // log_error("dump\n");

        return connections;
    }

    //! Locates the error sink in the top module, i.e. the place where we route the voter error signal to. If
    //! there is no error sink, this will raise a warning. We look for output wires from the module with the
    //! annotation (* tamara_error_sink *).
    void locateErrorSink(RTLIL::Module *module) {
        errorSink = std::nullopt;
        for (const auto &wire : module->wires()) {
            if (wire->has_attribute(ERROR_SINK_ANNOTATION)) {
                if (errorSink.has_value()) {
                    log_error("Duplicate error sink: '%s'. Only one error sink is allowed per top module.\n",
                        log_id(wire));
                }

                log("Found error sink: %s\n", log_id(wire->name));
                errorSink = wire;
            }
        }

        if (!errorSink.has_value()) {
            log_warning("No error sink found for top module. The 'err' signal from TaMaRa voters will not be "
                        "routed anywhere! You should add (* tamara_error_sink *) to a wire.\n");
        }
    }

    void sinkVoters(VoterBuilder &builder) {
    }

} const TamaraTMRPass;

} // namespace tamara
