// TaMaRa: An automated triple modular redundancy EDA flow for Yosys.
//
// Copyright (c) 2024 Matt Young.
//
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
#include "kernel/log.h"
#include "kernel/register.h"
#include "kernel/rtlil.h"
#include "kernel/yosys.h"
#include "kernel/yosys_common.h"
#include "tamara/logic_graph.hpp"
#include "tamara/termcolour.hpp"
#include "tamara/util.hpp"
#include "tamara/voter_builder.hpp"
#include <cmath>
#include <vector>

USING_YOSYS_NAMESPACE;

namespace {

/// Locates and marks $mem cells as ignored
void markMemoriesIgnored(RTLIL::Module *module) {
    bool haveWarned = false;

    for (const auto &cell : module->cells()) {
        if (cell->is_mem_cell()) {
            if (!haveWarned) {
                log_warning("This design contains memories, but TaMaRa currently does not triplicate them. "
                            "Instead, they will be ignored.\n");
                haveWarned = true;
            }
            cell->set_bool_attribute(tamara::IGNORE_ANNOTATION);
            log("Marking memory '%s' as ignored\n", log_id(cell->name));
        }
    }
}

}; // namespace

namespace tamara {

//! This is the main TaMaRa TMR command, which starts the TMR process.
struct TamaraTMRPass : public Pass {

    TamaraTMRPass()
        : Pass("tamara_tmr", "Performs TaMaRa TMR voter insertion and cell replication") {
    }

    void help() override {
        //   |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
        log("\n");
        log("    tamara_tmr\n");
        log("\n");

        log("TaMaRa is an automated triple modular redundancy flow for Yosys.\n");
        log("The 'tamara_tmr' command processes exactly one selected module in the\n");
        log("design, which should be the top module. It will apply TMR and insert\n");
        log("majority voters.\n\n");

        log("The 'tamara_tmr' command should be run after synthesis but before\n");
        log("techmapping.\n");
    }

    void execute(std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Running TaMaRa automated Triple Modular Redundancy flow\n\n");

        // FIXME: find module marked (* tamara_triplicate *)

        // we can only operate on one module
        if (design->top_module() == nullptr) {
            log_error("No top module selected\n");
        }

        auto *const module = design->top_module();
        log("Applying TMR to top module: %s\n", log_id(module->name));
        log_push();

        VoterBuilder builder(module);

        // locate the error sink (place where we route the voter 'err' signals too)
        log_header(design, "Locating error sink\n");
        locateErrorSink(design->top_module());

        // tag memories as ignore
        log_header(design, "Locating and marking memories as ignored\n");
        markMemoriesIgnored(module);

#if defined(TAMARA_DEBUG)
        if (getenv("TAMARA_DEBUG_BYPASS_VOTER") != nullptr) {
            log_header(design, "Preparing voter technology map");
            log("TAMARA_DEBUG_BYPASS_VOTER is set, so we need to load in the voter technology map, which we "
                "will do now.\n");
            // Yosys::run_pass("techmap -map ../src/voter.v;;");
            Yosys::run_pass("read_verilog -lib -specify ../src/voter.v");
        }
#endif

        // analyse wire connections, this is used later by the logic cone code for neighbour calculations
        // I thought that we might be able to get this through RTLIL directly, but I think we have to compute
        // it ourselves.
        // the main trouble is we have to compute it in reverse: that is, we want to know which _wires_ have
        // which _cells_ associated with them, but RTLIL will only tell us which _cells_ have which _wires_
        // associated with them.
        log_header(design, "Analysing connections\n");
        auto connections = analyseAll(module);

        // figure out where our output ports are, these will be the start of the BFS
        log_header(design, "Computing initial logic graph\n");
        auto outputs = getOutputPorts(module);
        log("Module has %zu output ports, %zu selected cells\n\n", outputs.size(),
            module->selected_cells().size());

        DUMPASYNC;

        // this is a list of successors generated by the backwards BFS
        auto successors = std::queue<LogicCone>();

        for (const auto &output : outputs) {
            // don't consider ports marked (* tamara_error_sink *)
            if (output->has_attribute(ERROR_SINK_ANNOTATION)) {
                log("Skipping output '%s', marked as TaMaRa error sink\n\n", log_id(output->name));
                continue;
            }

            log("Searching from output port %s\n", log_id(output->name));
            auto cone = LogicCone(output);

            // start at the output port, do a BFS backwards to build up our logic cones
            cone.search(connections);
            log("\n");

            // cone is built, replicate items
            cone.replicate(module);
            log("\n");

            // wire up the netlist, and insert a voter
            cone.wire(module, connections, builder);
            log("\n");

            // generate successors
            auto coneSuccessors = cone.buildSuccessors(connections);
            for (const auto &successor : coneSuccessors) {
                successors.push(successor);
            }
            log("\n");
        }

        DUMPASYNC;

        log_header(design, "Computing successor logic graph (%zu successors)\n", successors.size());
        while (!successors.empty()) {
            auto cone = successors.front();
            successors.pop();

            // start at the output port, do a BFS backwards to build up our logic cones
            cone.search(connections);
            log("\n");

            // cone is built, replicate items
            cone.replicate(module);
            log("\n");

            // wire up the netlist
            cone.wire(module, connections, builder);
            log("\n");

            // generate successors
            auto coneSuccessors = cone.buildSuccessors(connections);
            for (const auto &successor : coneSuccessors) {
                successors.push(successor);
            }
            log("\n");
        }

        // collect all error signals from all voters in the design, ORs them together, and connects them to
        // the (* tamara_error_sink *) node (if it exists).
        log_header(design, "Sinking error nodes into (* tamara_error_sink *)\n");
        if (errorSink.has_value()) {
            log("Sinking %zu voters into (* tamara_error_sink *) %s\n", builder.getSize(),
                log_id(errorSink.value()->name));
            builder.finalise(errorSink.value());
        } else {
            log_warning("Cannot sink voters into error sink because no error sink was found!\n");
        }

        log("\n===============================\n");
        log("%sTaMaRa TMR pass completed!%s\n", termcolour::colour(termcolour::Colour::Green).c_str(),
            termcolour::reset().c_str());
        log("===============================\n");
        log_pop();
    }

private:
    std::optional<RTLIL::Wire *> errorSink;

    //! Returns output wires for a module
    static std::vector<RTLIL::Wire *> getOutputPorts(RTLIL::Module *module) {
        std::vector<RTLIL::Wire *> out {};
        for (const auto &wire : module->wires()) {
            if (wire->port_output) {
                out.push_back(wire);
            }
        }
        return out;
    }

    //! Locates the error sink in the top module, i.e. the place where we route the voter error signal to. If
    //! there is no error sink, this will raise a warning. We look for output wires from the module with the
    //! annotation (* tamara_error_sink *).
    void locateErrorSink(RTLIL::Module *module) {
        errorSink = std::nullopt;
        for (const auto &wire : module->wires()) {
            if (wire->has_attribute(ERROR_SINK_ANNOTATION)) {
                if (errorSink.has_value()) {
                    log_error("Duplicate error sink: '%s'. Only one error sink is allowed per top module.\n",
                        log_id(wire));
                }

                log("Found error sink: %s\n", log_id(wire->name));
                errorSink = wire;
            }
        }

        if (!errorSink.has_value()) {
            log_warning("No error sink found for top module. The 'err' signal from TaMaRa voters will not be "
                        "routed anywhere!\nYou should add (* tamara_error_sink *) to a wire.\n");
        }
    }
} const TamaraTMRPass;

} // namespace tamara
